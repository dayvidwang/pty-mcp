import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js"
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js"
import { z } from "zod"
import { HeadlessTerminal } from "./terminal"
import { renderToPng } from "./renderer"

// Session management: map of session IDs to terminal instances
const sessions = new Map<string, HeadlessTerminal>()
let nextId = 1

function getSession(id: string): HeadlessTerminal {
  const session = sessions.get(id)
  if (!session) throw new Error(`No terminal session with id: ${id}`)
  return session
}

const server = new McpServer({
  name: "terminal-mcp",
  version: "0.1.0",
})

// --- Tools ---

server.tool(
  "terminal_spawn",
  "Spawn a new headless terminal session with a shell or command",
  {
    shell: z.string().optional().describe("Shell to use (default: $SHELL or /bin/bash)"),
    args: z.array(z.string()).optional().describe("Arguments for the shell/command"),
    cols: z.number().optional().describe("Terminal width in columns (default: 120)"),
    rows: z.number().optional().describe("Terminal height in rows (default: 40)"),
    cwd: z.string().optional().describe("Working directory"),
    env: z.record(z.string()).optional().describe("Additional environment variables"),
  },
  async ({ shell, args, cols, rows, cwd, env }) => {
    const id = `term-${nextId++}`
    const terminal = new HeadlessTerminal({
      cols: cols ?? 120,
      rows: rows ?? 40,
      shell,
      args,
      cwd,
      env,
    })
    terminal.spawn({ shell, args, cwd, env })
    sessions.set(id, terminal)

    // Give shell a moment to initialize
    await Bun.sleep(200)
    await terminal.flush()

    return {
      content: [
        {
          type: "text" as const,
          text: JSON.stringify({
            sessionId: id,
            cols: terminal.cols,
            rows: terminal.rows,
          }),
        },
      ],
    }
  },
)

server.tool(
  "terminal_write",
  "Send input (keystrokes, text, control sequences) to a terminal session",
  {
    sessionId: z.string().describe("Terminal session ID"),
    data: z.string().describe("Data to write (text, or escape sequences like \\x03 for Ctrl+C, \\r for Enter)"),
  },
  async ({ sessionId, data }) => {
    const terminal = getSession(sessionId)

    // Unescape common control sequences from the string
    const unescaped = data
      .replace(/\\r/g, "\r")
      .replace(/\\n/g, "\n")
      .replace(/\\t/g, "\t")
      .replace(/\\x([0-9a-fA-F]{2})/g, (_, hex) => String.fromCharCode(parseInt(hex, 16)))
      .replace(/\\e/g, "\x1b")

    terminal.write(unescaped)

    // Wait for output to be processed
    await Bun.sleep(100)
    await terminal.flush()

    return {
      content: [{ type: "text" as const, text: `Wrote ${unescaped.length} bytes to ${sessionId}` }],
    }
  },
)

server.tool(
  "terminal_screenshot",
  "Take a screenshot of the current terminal state. Returns both a PNG image and the text content.",
  {
    sessionId: z.string().describe("Terminal session ID"),
    format: z
      .enum(["png", "text", "both"])
      .optional()
      .describe("Output format: png (image), text (plain text), or both (default: both)"),
  },
  async ({ sessionId, format }) => {
    const terminal = getSession(sessionId)
    await terminal.flush()

    const fmt = format ?? "both"
    const content: Array<
      | { type: "text"; text: string }
      | { type: "image"; data: string; mimeType: string }
    > = []

    if (fmt === "text" || fmt === "both") {
      content.push({
        type: "text" as const,
        text: terminal.getText(),
      })
    }

    if (fmt === "png" || fmt === "both") {
      const grid = terminal.getCellGrid()
      const png = renderToPng(grid, terminal.cols, terminal.rows)
      content.push({
        type: "image" as const,
        data: png.toString("base64"),
        mimeType: "image/png",
      })
    }

    return { content }
  },
)

server.tool(
  "terminal_resize",
  "Resize a terminal session",
  {
    sessionId: z.string().describe("Terminal session ID"),
    cols: z.number().describe("New width in columns"),
    rows: z.number().describe("New height in rows"),
  },
  async ({ sessionId, cols, rows }) => {
    const terminal = getSession(sessionId)
    terminal.resize(cols, rows)
    await Bun.sleep(50)
    await terminal.flush()

    return {
      content: [{ type: "text" as const, text: `Resized ${sessionId} to ${cols}x${rows}` }],
    }
  },
)

server.tool(
  "terminal_kill",
  "Kill a terminal session and clean up resources",
  {
    sessionId: z.string().describe("Terminal session ID"),
  },
  async ({ sessionId }) => {
    const terminal = getSession(sessionId)
    terminal.destroy()
    sessions.delete(sessionId)

    return {
      content: [{ type: "text" as const, text: `Killed session ${sessionId}` }],
    }
  },
)

server.tool(
  "terminal_list",
  "List all active terminal sessions",
  {},
  async () => {
    const list = Array.from(sessions.entries()).map(([id, term]) => ({
      id,
      cols: term.cols,
      rows: term.rows,
      exited: term.exited,
      exitCode: term.exitCode,
    }))

    return {
      content: [{ type: "text" as const, text: JSON.stringify(list, null, 2) }],
    }
  },
)

server.tool(
  "terminal_wait",
  "Wait for terminal output to settle (useful after running a command)",
  {
    sessionId: z.string().describe("Terminal session ID"),
    ms: z.number().optional().describe("Milliseconds to wait (default: 500)"),
  },
  async ({ sessionId, ms }) => {
    const terminal = getSession(sessionId)
    await Bun.sleep(ms ?? 500)
    await terminal.flush()

    return {
      content: [{ type: "text" as const, text: terminal.getText() }],
    }
  },
)

// --- Start ---

const transport = new StdioServerTransport()
await server.connect(transport)
